"""Unit tests for event delegation."""
# pylint: disable=missing-docstring,too-few-public-methods


from twisted.internet.defer import Deferred

from ..message import Message, collapse
from ..plugin import EventPlugin, UserVisibleError
from .helpers import AbstractConnectionTestCase


#
# Base case
#

class EmptyPluginTestCase(AbstractConnectionTestCase):
    def test_empty_plugin(self):
        self.connection.add_event_plugin(EventPlugin, {})


#
# Simple event delegation
#

class NoticingPlugin(EventPlugin):
    def __init__(self, bot):
        self.bot = bot
        self.seen = []

    def on_privmsg(self, msg):
        self.seen.append(msg)

    on_command = on_join = on_quit = on_privmsg


class EventDelegationTestCase(AbstractConnectionTestCase):
    def setUp(self):
        super(EventDelegationTestCase, self).setUp()
        self.plugin = self.connection.add_event_plugin(
            NoticingPlugin, {'#foo': ['spam'], '#bar': []})

    def test_init(self):
        self.assertEqual(self.plugin.bot, self.connection)

    def test_privmsg(self):
        self.receive('PRIVMSG #foo :lorem ipsum')
        self.assertEqual(len(self.plugin.seen), 1)
        last_seen = self.plugin.seen[0]
        self.assertEqual(last_seen.actor, self.other_user)
        self.assertEqual(last_seen.action, 'privmsg')
        self.assertEqual(last_seen.venue, '#foo')
        self.assertEqual(last_seen.content, 'lorem ipsum')
        self.assertFalse(last_seen.private)

    def test_privmsg_casemapping(self):
        # This will no longer be a direct part of the event delegation
        # code once the new settings machinery works, but it might not
        # be a bad idea to keep this around as an integration test with
        # various settings for the case mapping.
        self.receive('PRIVMSG #FOO :lorem ipsum')
        self.assertEqual(len(self.plugin.seen), 1)
        last_seen = self.plugin.seen[0]
        self.assertEqual(last_seen.actor, self.other_user)
        self.assertEqual(last_seen.action, 'privmsg')
        self.assertEqual(last_seen.venue, '#FOO')
        self.assertEqual(last_seen.content, 'lorem ipsum')
        self.assertFalse(last_seen.private)

    def test_command_enabled(self):
        self.receive('PRIVMSG #foo :!spam ham eggs')
        self.assertEqual(len(self.plugin.seen), 2)
        last_seen = self.plugin.seen[1]
        self.assertEqual(last_seen.actor, self.other_user)
        self.assertEqual(last_seen.action, 'command')
        self.assertEqual(last_seen.venue, '#foo')
        self.assertEqual(last_seen.target, 'other')
        self.assertEqual(last_seen.subaction, 'spam')
        self.assertEqual(last_seen.content, 'ham eggs')
        self.assertFalse(last_seen.private)

    def test_command_disabled(self):
        self.receive('PRIVMSG #bar :!spam ham eggs')
        self.assertEqual(len(self.plugin.seen), 1)  # no command message

    def test_visible_quit(self):
        self.connection.joined('#foo')
        self.connection.channel_names['#foo'].add(self.other_user.nick)
        self.receive('QUIT :Client Quit')
        self.assertEqual(len(self.plugin.seen), 1)
        last_seen = self.plugin.seen[0]
        self.assertEqual(last_seen.actor, self.other_user)
        self.assertEqual(last_seen.action, 'quit')
        self.assertIsNone(last_seen.venue)
        self.assertEqual(last_seen.content, 'Client Quit')
        self.assertFalse(last_seen.private)

    def test_visible_quit_call_once(self):
        for channel in ('#foo', '#bar'):
            self.connection.joined(channel)
            self.connection.channel_names[channel].add(self.other_user.nick)
        self.receive('QUIT :Client Quit')
        self.assertEqual(len(self.plugin.seen), 1)

    def test_invisible_quit(self):
        self.receive('QUIT :Client Quit')
        self.assertEqual(len(self.plugin.seen), 0)


#
# Event ordering
#

class OrderingPluginOne(EventPlugin):
    def __init__(self, bot):
        self.quote = 'dolor sit amet'

    def on_privmsg(self, msg):
        msg.connection.msg(msg.venue, self.quote)


class OrderingPluginTwo(EventPlugin):
    def __init__(self, bot):
        self.seen = []

    def on_privmsg(self, msg):
        self.seen.append(msg)
    on_privmsg.outgoing = True

    on_command = on_privmsg


class EventOrderingTestCase(AbstractConnectionTestCase):
    def setUp(self):
        super(EventOrderingTestCase, self).setUp()
        self.plugin_one = self.connection.add_event_plugin(
            OrderingPluginOne, {'#foo': []})
        self.plugin_two = self.connection.add_event_plugin(
            OrderingPluginTwo, {'#foo': ['spam']})

    def test_callback_ordering(self):
        """Ensure that messages generated by plugin callbacks are only
        processed after the message that triggered the callbacks."""
        self.receive('PRIVMSG #foo :lorem ipsum')
        seen = self.plugin_two.seen
        self.assertEqual(len(seen), 2)
        self.assertEqual(seen[0].content, 'lorem ipsum')
        self.assertEqual(seen[1].content, 'dolor sit amet')

    def test_immediate_command(self):
        """Ensure that command messages generated from privmsg messages
        are processed immediately after their originators."""
        self.receive('PRIVMSG #foo :!spam')
        seen = self.plugin_two.seen
        self.assertEqual(len(seen), 3)
        self.assertEqual(seen[0].action, 'privmsg')
        self.assertEqual(seen[0].content, '!spam')
        self.assertEqual(seen[1].action, 'command')
        self.assertEqual(seen[1].subaction, 'spam')
        self.assertEqual(seen[2].action, 'privmsg')
        self.assertEqual(seen[2].content, 'dolor sit amet')


#
# Outgoing events
#

class OutgoingPlugin(NoticingPlugin):
    def on_privmsg(self, msg):
        super(OutgoingPlugin, self).on_privmsg(msg)
    on_privmsg.outgoing = True

    on_command = on_join = on_quit = on_privmsg


class OutgoingEventTestCase(AbstractConnectionTestCase):
    def setUp(self):
        super(OutgoingEventTestCase, self).setUp()
        self.outgoing = self.connection.add_event_plugin(
            OutgoingPlugin, {'#foo': ['spam']})
        self.no_outgoing = self.connection.add_event_plugin(
            NoticingPlugin, {'#foo': ['spam']})

    def test_own_privmsg(self):
        self.connection.sendLine('PRIVMSG #foo :lorem ipsum')
        self.assertEqual(len(self.outgoing.seen), 1)
        last_seen = self.outgoing.seen[0]
        self.assertTrue(last_seen.actor.matches(self.connection.nickname))
        self.assertEqual(last_seen.action, 'privmsg')
        self.assertEqual(last_seen.venue, '#foo')
        self.assertEqual(last_seen.content, 'lorem ipsum')
        self.assertFalse(last_seen.private)
        self.assertEqual(len(self.no_outgoing.seen), 0)

    def test_own_command(self):
        self.connection.sendLine('PRIVMSG #foo :!spam ham eggs')
        self.assertEqual(len(self.outgoing.seen), 2)
        self.assertEqual(len(self.no_outgoing.seen), 0)

    def test_own_join(self):
        self.connection.sendLine('JOIN #foo')
        self.assertEqual(len(self.outgoing.seen), 1)
        self.assertEqual(len(self.no_outgoing.seen), 0)

    def test_echoed_join(self):
        self.echo('JOIN #foo')
        self.assertEqual(len(self.outgoing.seen), 1)
        self.assertEqual(len(self.no_outgoing.seen), 1)

    def test_own_quit(self):
        self.connection.joined('#foo')
        self.connection.channel_names['#foo'].add(self.connection.nickname)
        self.connection.sendLine('QUIT :Client Quit')
        self.assertEqual(len(self.outgoing.seen), 1)
        self.assertEqual(len(self.no_outgoing.seen), 0)

    def test_echoed_quit(self):
        self.connection.joined('#foo')
        self.connection.channel_names['#foo'].add(self.connection.nickname)
        self.echo('QUIT :Client Quit')
        self.assertEqual(len(self.outgoing.seen), 1)
        self.assertEqual(len(self.no_outgoing.seen), 1)


#
# Deferred callbacks
#

class DeferredPlugin(EventPlugin):
    def __init__(self, bot):
        self.seen = []

    def on_privmsg(self, msg):
        deferred = Deferred()
        deferred.addCallback(self.seen.append)
        callLater = msg.connection.reactor.callLater
        if msg.content == 'failure':
            callLater(1, deferred.errback, Exception())
        else:
            callLater(1, deferred.callback, msg)
        return deferred


class DeferredCallbackTestCase(AbstractConnectionTestCase):
    def setUp(self):
        super(DeferredCallbackTestCase, self).setUp()
        self.plugin = self.connection.add_event_plugin(
            DeferredPlugin, {'#foo': []})

    def test_deferred_callback(self):
        deferred = self.connection.respond_to(Message.from_raw(
            self.connection, False, 'PRIVMSG #foo :lorem ipsum'))
        deferred.addCallback(
            lambda _: self.assertEqual(len(self.plugin.seen), 1))
        self.connection.reactor.advance(2)
        return deferred

    def test_default_errback(self):
        deferred = self.connection.respond_to(Message.from_raw(
            self.connection, False, 'PRIVMSG #foo :failure'))
        deferred.addCallback(lambda _: self.assertLoggedErrors(1))
        self.connection.reactor.advance(2)
        return deferred


#
# Command callbacks
#

class CommandTestDummy(EventPlugin):
    quote = collapse("""Deliquatue volut pulvinar feugiat eleifend
        quisque suspendisse faccummy etuerci; vullandigna praestie hac
        consectem ipisim esequi. Facidui augiam proin nisit diamet ing.
        Incinim iliquipisl ero alit amconsecte adionse loborer
        odionsequip sagittis, iuscipit hent dipiscipit. Molore proin
        consecte min amcommo; lobortio platea loboreet il consequis. Lan
        ullut corem esectem vercilisit delent exer, feu inciduipit feum
        in augait vullam. Tortor augait dignissim.""")

    def on_command(self, msg):
        args = msg.content.split()
        exc = (UserVisibleError if 'visible' in args else Exception)(
            'lorem ipsum')
        if 'defer' in args:
            deferred = Deferred()
            deferred.addCallback(lambda _: self.quote)
            callLater = msg.connection.reactor.callLater
            if 'failure' in args:
                callLater(1, deferred.errback, exc)
            else:
                callLater(1, deferred.callback, msg)
            return deferred
        if 'failure' in args:
            raise exc
        return self.quote


class CommandReplyTestCase(AbstractConnectionTestCase):
    def setUp(self):
        super(CommandReplyTestCase, self).setUp()
        self.command = self.connection.add_event_plugin(
            CommandTestDummy, {'#foo': ['spam']})
        self.watcher = self.connection.add_event_plugin(
            OutgoingPlugin, {'#foo': []})
        self.connection.joined('#foo')

    def assert_success(self, _=None):
        last_seen = self.watcher.seen[-1]
        self.assertEqual(last_seen.action, 'privmsg')
        self.assertEqual(last_seen.venue, '#foo')
        self.assertEqual(last_seen.content, collapse("""\x0314party3:
            Deliquatue volut pulvinar feugiat eleifend quisque
            suspendisse faccummy etuerci; vullandigna praestie hac
            consectem ipisim esequi. Facidui augiam proin nisit diamet
            ing. Incinim iliquipisl ero alit amconsecte adionse loborer
            odionsequip sagittis, (+210 more characters)"""))
        rb = self.connection.message_buffers['#foo'][self.other_user.nick]
        self.assertEqual(next(rb), collapse("""iuscipit hent dipiscipit.
            Molore proin consecte min amcommo; lobortio platea loboreet
            il consequis. Lan ullut corem esectem vercilisit delent
            exer, feu inciduipit feum in augait vullam. Tortor augait
            dignissim."""))

    def assert_hidden_error(self, _=None):
        last_seen = self.watcher.seen[-1]
        self.assertEqual(last_seen.action, 'privmsg')
        self.assertEqual(last_seen.venue, '#foo')
        self.assertEqual(last_seen.content, collapse("""\x0314{}:
            Command \x02spam\x02 encountered an error.""".format(
                self.other_user.nick)))
        self.assertLoggedErrors(1)

    def assert_visible_error(self, _=None):
        last_seen = self.watcher.seen[-1]
        self.assertEqual(last_seen.action, 'privmsg')
        self.assertEqual(last_seen.venue, '#foo')
        self.assertEqual(last_seen.content, collapse("""\x0314{}:
            Command \x02spam\x02 encountered an error: lorem
            ipsum.""".format(self.other_user.nick)))

    def test_synchronous_success(self):
        self.receive('PRIVMSG #foo :!spam > party3')
        self.assert_success()

    def test_synchronous_hidden_error(self):
        self.receive('PRIVMSG #foo :!spam failure > party3')
        self.assert_hidden_error()

    def test_synchronous_visible_error(self):
        self.receive('PRIVMSG #foo :!spam failure visible > party3')
        self.assert_visible_error()

    def test_deferred_success(self):
        deferred = self.receive('PRIVMSG #foo :!spam defer > party3')
        deferred.addCallback(self.assert_success)
        self.connection.reactor.advance(2)
        return deferred

    def test_deferred_hidden_error(self):
        deferred = self.receive('PRIVMSG #foo :!spam defer failure > party3')
        deferred.addCallback(self.assert_hidden_error)
        self.connection.reactor.advance(2)
        return deferred

    def test_deferred_visible_error(self):
        deferred = self.receive(
            'PRIVMSG #foo :!spam defer failure visible > party3')
        deferred.addCallback(self.assert_visible_error)
        self.connection.reactor.advance(2)
        return deferred
